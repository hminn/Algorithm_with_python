## **야근 지수**

### **문제 설명**

회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.

### **제한 사항**

- **`works`**는 길이 1 이상, 20,000 이하인 배열입니다.
- **`works`**의 원소는 50000 이하인 자연수입니다.
- **`n`**은 1,000,000 이하인 자연수입니다.

### **입출력 예**

[Untitled](https://www.notion.so/4a8d48f3823e4e2286ca2b9f9dded83e)

### **입출력 예 설명**

입출력 예 #1 n=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 4시간동안 일을 한 결과는 [2, 2, 2]입니다. 이 때 야근 지수는 22 + 22 + 22 = 12 입니다.

입출력 예 #2 n=1일 때, 남은 일의 작업량이 [2,1,2]라면 야근 지수를 최소화하기 위해 1시간동안 일을 한 결과는 [1,1,2]입니다. 야근지수는 12 + 12 + 22 = 6입니다.

### **풀이 1 : 내장 함수를 이용하여 최댓값 Searching**

```python
 def solution(n, works):
     while n:
         works[works.index(max(works))] -= 1
         n -= 1
         if (sum(works) == 0):
             break
     return sum([x**2 for x in works])
```

- 내장함수를 이용하여 간단하게 구현하였으나, 시간 복잡도에서 터짐 (0.98ms)
- 시간복잡도 : O(works의 길이 x n x i(index))
- 아마도 index 함수를 쓰지 않고 구현해야 통과가 될 것 같다는 판단.

**=> 여러 풀이로 접근해도 모르겠어서 해당 문제를 검색해보니 최대힙 자료구조를 이용해야 시간복잡도 문제를 해결할 수 있는 문제였다.**

### 파이썬 힙 자료구조

**Heap(힙) 이란?

- 힙은 최댓값 및 최솟값을 찾아내는 연산을 빠르게 하기 위해 고완된 완전이진트리를 기본으로 한 자료구조이다.
- 최대힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰 힙
- 최소힙 : 부모 노드의 키 값이 자식 노드의 키 값보다 항상 작은 힙
- 힙의 시간복잡도는 삽입, 삭제 모두 O(log n)이다. ⇒ 원소의 삽입, 삭제가 일어날 때 전체 원소의 반 만큼의 값과 비교하기 때문.**

**파이썬 `heapq` 모듈은 heapq (priority queue) 알고리즘을 제공한다.**

**모든 부모 노드는 그의 자식 노드보다 값이 작거나 큰 이진트리(binary tree) 구조인데, 내부적으로는 인덱스 0에서 시작해 k번째 원소가 항상 자식 원소들(2k+1, 2k+2) 보다 작거나 같은 최소 힙의 형태로 정렬된다.

`heapq`는 내장 모듈로 별도의 설치 작업 없이 바로 사용할 수 있다.**

**Heap 함수 활용하기

- `heapq.heappush(heap, item)` : item을 heap에 추가
- `heapq.heappop(heap)` : heap에서 가장 작은 원소를 pop & 리턴
- `heapq.heapify(x)` : 리스트 x를 즉각적으로 heap으로 변환, 시간복잡도 : O(N)**

**최대 힙 만들기 :** 파이썬의 heapq 모듈은 최소 힙으로 구현되어 있기 때문에 최대 힙 구현을 위해서는 트릭이 필요하다.

**< IDEA > : y = -x 변환을 하면 최솟값 정렬이 최댓값 정렬로 바뀐다.**



### 풀이2 : 최대 힙을 이용한 풀이

```python
import heapq

def solution(n, works):
    works = [-x for x in works]
    heapq.heapify(works)
    while n:
        heapq.heappush(works, heapq.heappop(works) + 1)
        n -= 1
    return sum([(-x)**2 for x in works]) if sum(works) <= 0 else 0
```

- 풀이1 에서 while 문 안에 if 문을 넣어놨는데 생각해보니 여기서도 시간을 잡아먹고 있었음.
- 가지치기라고 생각했던 부분이 실제로 계산을 해봤을 때는 그렇지 않을 수도 있음을 명심하자.
- 파이써닉한 코드에 익숙해지자
- 정렬이 필요한(최대값과 최솟값이 필요한) 자료구조 ⇒ **힙!**