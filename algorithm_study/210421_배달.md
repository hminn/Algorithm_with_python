## 배달

###### 문제 설명

N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.

![배달_1_uxun8t.png](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d7779d88-084c-4ffa-ae9f-2a42f97d3bbf/%E1%84%87%E1%85%A2%E1%84%83%E1%85%A1%E1%86%AF_1_uxun8t.png)

위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.
마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- 마을의 개수 N은 1 이상 50 이하의 자연수입니다.
- road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.
- road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.
- road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.
  - a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.
  - 두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.
  - 한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.
- K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.
- 임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.
- 1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.



### 풀이 1 : DFS(깊이우선탐색)를 이용한 풀이

```python
def dfs(start, arr, N, K, answer):
    for col in range(start + 1, N):
        if arr[start][col] == 0:
            continue
        if arr[start][col] < K:
            answer[0] += 1
            dfs(col, arr, N, K - arr[start][col], answer)
        elif arr[start][col] == K:
            answer[0] += 1

def solution(N, road, K):
    # 2차원 배열 초기화
    arr = [[0 for _ in range(N)] for _ in range(N)]
    # 2차원 배열에 데이터 푸시
    for r in road:
        x, y = (r[0], r[1]) if r[0] < r[1] else (r[1], r[0])
        arr[x - 1][y - 1] = r[2]
    answer = [0]
    dfs(0, arr, N, K, answer)
    return answer[0] + 1
```

- road 데이터를 매트릭스 형태의 2차원 배열로 변환

- DFS 알고리즘으로 접근
  -> 1번 마을에서 시작하여 갈 수 있는 경로들을 재귀적으로 접근
  -> 각 스텝마다 걸리는 시간들을 계산, K를 초과하면 더 이상 들어갈 수 없도록
  1) 해당 경로까지 걸리는 시간이 K 미만?
  => 해당 마을까지 배달 가능 하므로 answer += 1 (갈 수 있는 마을 카운팅)
  => 다음 경로로 나아갈 수 있으므로 DFS 재귀 호출하여 진입

  2) 해당 경로까지 걸리는 시간이 딱 K?
  => 해당 마을까지 배달 가능 하므로 answer += 1 (갈 수 있는 마을 카운팅)
  => 다음 마을로 진출 불가하므로 종료

- 그럴 듯해 보이나, 실제로 돌리면 처참한 결과를 맞딱뜨리게 된다.

#### 풀이1 문제점

- K 값이 모든 경로를 품을 정도로 커지면 중복되어 카운트가 된다.
  -> K 값이 커지면 하나의 마을이 여러 경로에 포함될 수 있음을 간과하였다.

##### **=> 그럼 가능한 모든 경로를 담고, 경로에 존재하는 마을만 카운트하면 되지 않을까?**



### 풀이 2 : DFS(깊이우선탐색)를 이용하여 가능한 경로 Stacking

```python
def dfs(start, arr, N, K, stack):
    for col in range(start + 1, N):
        if arr[start][col] == 0:
            continue
        if arr[start][col] <= K:
            stack[-1].append(col)
            if arr[start][col] < K:
                dfs(col, arr, N, K - arr[start][col], stack)
    stack.append([])

def solution(N, road, K):
    arr = [[0 for _ in range(N)] for _ in range(N)]
    for r in road:
        x, y = (r[0], r[1]) if r[0] < r[1] else (r[1], r[0])
        arr[x - 1][y - 1] = r[2] if arr[x - 1][y - 1] == 0 else min(arr[x - 1][y - 1], r[2])
    stack = [[]]
    dfs(0, arr, N, K, stack)
    return len(set(sum(stack, []))) + 1
```

- 이전 풀이에서 오류나는 부분은 잡았으나, 다른 케이스에서 실패가 뜬다.
- 설상가상으로 시간복잡도도 맞추지 못해 풀이 방식을 바꿔야할 듯 하다.
- 하나의 문제에 너무 오랜 시간 투자하지 말고 충분히 생각했다싶으면 바로바로 피드백 하자.



### Feedback

#### => 핵심은 다익스트라 알고리즘(Dijkstra Algorithm)

#### 1. 다익스트라 알고리즘이란?

: 다익스트라 알고리즘은 연결되어있는 그래프에서 1개의 노드에서 출발하여, 다른 모든 노드까지의 최단 경로를 출력해주는 알고리즘

- 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류된다.  
  (매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복)

#### 2. 다익스트라 알고리즘 동작과정

1. 출발 노드를 설정
2. 최단 거리 테이블을 초기화
3. **방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택**  
   => 선형 탐색을 하는 경우 O(N) 의 시간복잡도가 걸리게 된다.  
   => 따라서 전체 시간 복잡도는 O(N²)  
   => 노드의 개수가 커져감에 따라 시간 복잡도는 기하급수적으로 상승하게 될 것임.  
   => **이러한 문제를 해결하기 위해 '우선순위 큐' 자료구조를 이용하는 게 대표적인 방법**
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산, 최단 거리 테이블 갱신
5. 위 과정에서 3번과 4번을 반복

![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/993685f2-6b97-4fe3-85b5-47c085dc1bf3/%E1%84%87%E1%85%A2%E1%84%83%E1%85%A1%E1%86%AF_3_njc7kq.png)

##### => 위의 케이스 그림에 적용하며 이해해보자!



### 풀이3 : 다익스트라 알고리즘을 이용한 풀이 with 우선순위 큐

```python
import heapq as hq

def dijkstra(road, N):
    queue = []
    hq.heappush(queue, [1, 0])
    dist = [float('inf')] * (N + 1)
    dist[1] = 0
    while queue:
        current, current_cost = hq.heappop(queue)
        for src, dest, cost in road:
            total_cost = current_cost + cost
            if src == current and dist[dest] > total_cost:
                dist[dest] = total_cost
                hq.heappush(queue, [dest, total_cost])
            elif dest == current and dist[src] > total_cost:
                dist[src] = total_cost
                hq.heappush(queue, [src, total_cost])
    return dist

def solution(N, road, K):
    dist = dijkstra(road, N)
    return len([x for x in dist if x <= K])
```



### Check Point

#### 1. 함수의 인자 전달 방식 : Call by Value? Call by Reference?  **Call by assignment** !

- #### **Call by value : 변수를 복사한 값을 전달하는 방식**

- #### **Call by reference : 인자로 받은 변수의 주소 값을 전달하는 것**

=> 파이썬의 경우, **Call by assignment**(**Call by object-reference**) 이다.
=> Immutable Object의 경우에는 Call by Value 방식으로,
=> Mutable Object의 경우에는 Call by Reference의 방식으로 인자가 전달된다.
=> Immutable : int, float, str, tuples
=> Mutable : list, dict, set

#### 2. 2차원 리스트를 1차원 리스트로 풀어내기

#### 3. 다익스트라 알고리즘(Dijkstra Algorithm)

#### 4. 우선순위 큐(Priority Queue)

